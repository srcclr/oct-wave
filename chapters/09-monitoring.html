
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Monitoring as Testing Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 3.4.0">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="07-update-advisor.html" />
    
    
    <link rel="prev" href="10-cypress.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Preface
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="00-introduction.html">
            
                <a href="00-introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="01-automated-test-case-generation.html">
            
                <a href="01-automated-test-case-generation.html">
            
                    
                    Beyond Unit Tests: Automated Test Case Generation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="02-property-based-testing.html">
            
                <a href="02-property-based-testing.html">
            
                    
                    Beyond Unit Tests: Property-based Testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="04-functional.html">
            
                <a href="04-functional.html">
            
                    
                    Execute Your User Stories!
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="05-where-is-my-casette.html">
            
                <a href="05-where-is-my-casette.html">
            
                    
                    Where is my cassette? Mocking system testing using capture and replay
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="06-contract.html">
            
                <a href="06-contract.html">
            
                    
                    Contract testing with Pact
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" >
            
                <span>
            
                    
                    Test Containers
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="10-cypress.html">
            
                <a href="10-cypress.html">
            
                    
                    E2E with Cypress
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.10" data-path="09-monitoring.html">
            
                <a href="09-monitoring.html">
            
                    
                    Monitoring as Testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="07-update-advisor.html">
            
                <a href="07-update-advisor.html">
            
                    
                    Proof Pearl: On the Correctness of Update Advisor
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="13-grammar.html">
            
                <a href="13-grammar.html">
            
                    
                    GramTest: a tool for grammar-based test case generation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="08-symbolic.html">
            
                <a href="08-symbolic.html">
            
                    
                    Dynamic Symbolic Execution with Pathgrind
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="09-efda.html">
            
                <a href="09-efda.html">
            
                    
                    EFDA: a benchmark for software composition analysis tools
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" >
            
                <span>
            
                    
                    Perspectives
            
                </span>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Monitoring as Testing</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="monitoring-as-testing">Monitoring as Testing</h1><p>We&apos;ve developed our app as sanely as we know how, applied every testing technique in the book, and our app is now live, with data from real users running through it. What comes next?</p><p>We&apos;re now past the point of detecting bugs early: now we want to ensure that we meet our availability targets, possibly with a bit of bug-finding so we know if things are not working. That&apos;s where monitoring comes in: it gives us ways to detect and recover from problems we didn&apos;t pick up earlier.</p><p>Monitoring is an umbrella term for a number of disparate activities, including the collection and visualization of metrics, management of alerts, or even lightweight smoke tests. They&apos;re all valuable and will be needed at some point, but in this chapter we&apos;ll focus on the automated aggregation of error conditions.</p><p>Sentry features heavily in this chapter, purely because it has an open source product that you can run yourself for free. There are lots of alternatives and everything here applies equally to all of them.</p><h2 id="sentry">Sentry</h2><p>As an app runs, errors will occur. We can recover from the expected ones, but because none of us are perfect (and also because our app ultimately runs on real hardware), unrecoverable errors <em>will</em> occur. A typical strategy is to log them and move on, because sometimes there really is no recourse but to abort to a known safe point (e.g. terminating the current request):</p><pre><code class="lang-java"><span class="hljs-meta">@PostMapping</span>(value = <span class="hljs-string">&quot;/jobs&quot;</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;Void&gt; <span class="hljs-title">startBatchJob</span><span class="hljs-params">(@RequestParam(value = <span class="hljs-string">&quot;id&quot;</span>)</span> <span class="hljs-keyword">long</span> id) </span>{
  <span class="hljs-keyword">try</span> {
    runJob();
    <span class="hljs-keyword">return</span> ResponseEntity.ok().build();
  } <span class="hljs-keyword">catch</span> (Exception e) {
    LOGGER.error(<span class="hljs-string">&quot;unexpected error&quot;</span>, e);
    <span class="hljs-keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
  }
}</code></pre>
<p>We might opt <em>not</em> catch errors as well, allowing them to go up the stack and be handled by the web framework, or even let them kill the server process and rely on a supervisor process or a cluster manager to restart it. These are more or less the same strategy <em>because the error disappears into a log somewhere and no one is alerted</em>.</p><p>This is fine for transient errors, but can we guarantee that every error we&apos;ve ignored this way is of that nature?</p><p>Sentry gives us a different strategy. It&apos;s a tool for aggregating errors, and it gives us a place to collect data on the kinds of errors that have occurred in the app and analyze it to make decisions.</p><h3 id="prioritization">Prioritization</h3><p><img alt="Sentry main page" src="../images/sentry1.png"></p><p>For a given app in Sentry, we can see a list of errors by type. There are also metrics like the number of affected users and the total number and frequency of occurrences.</p><p><img alt="frequency" src="../images/sentry2.png"></p><p>We can use this to tell if an error is still occurring, if it stopped a while ago (maybe someone else fixed it?), or if very long-standing (earliest) or infrequent (graph) issue; maybe then it&apos;s not super important that we fix it right now.</p><p>Maybe it was a severe bug that affected only a few users, and we want to know who those are -- that information is available too.</p><p>Sentry also has some bells and whistles around issue tracking, so you can use it for that as well if you don&apos;t have somthing else.</p><h3 id="reproducibility">Reproducibility</h3><p><img alt="Context" src="../images/sentry3.png"></p><p>Having context around error conditions is key to reproducing them and coming up with fixes. Sentry captures the exception type, message, and stack trace by default.</p><p><img alt="Environment" src="../images/sentry4.png"></p><p>User-defined metadata can also be associated with errors, so we can tag them with e.g. the version of the app it came from, or the users affected, or the specific inputs that caused it.</p><p>For client-side applications, things like the browser or OS it was running on, the version of e.g. the JVM the app was running on, and even <a href="https://docs.sentry.io/platforms/native/minidump/" target="_blank">memory dumps</a> can be captured.</p><h3 id="integration">Integration</h3><p>Integrating Sentry into an existing app is straightforward. Errors are sent over HTTP, so they can be sent manually if that&apos;s your thing, or in special cases.</p><p>A more principled way is to hook into the logging system, which ensures that if errors are handled consistently, they&apos;ll all appear in Sentry eventually.</p><pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;SENTRY&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;io.sentry.logback.SentryAppender&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>ERROR<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ROOT&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;SENTRY&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span></code></pre>
<p>Frameworks like Spring Boot provide hooks for handling uncaught exceptions thrown from any controller thread, so they can be logged or handled in a central place. This is perfect for sending them to Sentry. An example integration might look like the following:</p><pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SentryHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerExceptionResolver</span> </span>{

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER =
    LoggerFactory.getLogger(SentryHandler.class);

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Lookup LOOKUP = <span class="hljs-keyword">new</span> Lookup();

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(HttpServletRequest request,
    HttpServletResponse response, Object handler, Exception ex)</span> </span>{

    <span class="hljs-comment">// Reentrancy check</span>
    <span class="hljs-keyword">if</span> (SentryEnvironment.isManagingThread()) {
      <span class="hljs-keyword">return</span>;
    }

    SentryEnvironment.startManagingThread();
    <span class="hljs-keyword">try</span> {
      Sentry.getStoredClient().sendEvent(<span class="hljs-keyword">new</span> EventBuilder()
        .withRelease(LOOKUP.get(<span class="hljs-string">&quot;release&quot;</span>))
        .withSentryInterface(<span class="hljs-keyword">new</span> HttpInterface(request))
        .withSentryInterface(<span class="hljs-keyword">new</span> ExceptionInterface(ex)));
    } <span class="hljs-keyword">catch</span> (Exception e) {
      <span class="hljs-comment">// No recourse here, unfortunately; is Sentry down?</span>
      LOGGER.error(<span class="hljs-string">&quot;Sentry failed&quot;</span>, e);
    } <span class="hljs-keyword">finally</span> {
      SentryEnvironment.stopManagingThread();
    }

    <span class="hljs-comment">// Continue with the other configured HandlerExceptionResolvers</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
  }
}</code></pre>
<h2 id="monitoring-as-testing">Monitoring as Testing</h2><p>One might see monitoring as a form of integration testing for <em>unexpected</em> errors. This is in contrast to unit tests, which check only for expected errors.</p><ol><li>Each logging statement of this form
</li></ol>
<pre><code class="lang-java"><span class="hljs-keyword">try</span> {
  <span class="hljs-comment">// do something</span>
} <span class="hljs-keyword">catch</span> (E e) {
  LOGGER.error(<span class="hljs-string">&quot;unexpected&quot;</span>, e);
}</code></pre>
<p>can be seen as an assertion that the code in the <code>try</code> block <em>does not</em> throw the exception <code>E</code>.</p><ol><li><p>Uncaught exceptions are violations of the implicit assertion that all methods in the stack trace <em>do not</em> throw.</p></li>
<li><p>Violations of these assertions don&apos;t cause the app itself to crash (as <code>assert</code> statements would, which is why they can be (and are often) turned off). They are, however, surfaced in Sentry.</p></li></ol>
<p>Continuing the testing metaphor, these assertions have real inputs, unlike the synthetic inputs one comes up with in unit tests, or the artificial inputs one gets from fuzzing. This means that if you put in the work to have consistent error-handling, you can get a lot of mileage out of Sentry and reproducing bugs will become significantly easier.</p><p>As an integration testing method, monitoring also finds certain classes of bugs trivially, which is why we recommend using a mix of testing methods and not spending an inordinate amount of time on exhaustively covering paths with unit tests.</p><p>Finally, this method of integrating Sentry pairs well with <a href="https://github.com/EMResearch/EvoMaster" target="_blank">fuzz</a><a href="https://github.com/dariusf/befuzzle" target="_blank">ing</a>, providing a more granular oracle than one would have if relying only on, say, 5xx status codes.</p>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="10-cypress.html" class="navigation navigation-prev " aria-label="Previous page: E2E with Cypress">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="07-update-advisor.html" class="navigation navigation-next " aria-label="Next page: Proof Pearl: On the Correctness of Update Advisor">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Monitoring as Testing","level":"1.10","depth":1,"next":{"title":"Proof Pearl: On the Correctness of Update Advisor","level":"1.11","depth":1,"path":"chapters/07-update-advisor.md","ref":"chapters/07-update-advisor.md","articles":[]},"previous":{"title":"E2E with Cypress","level":"1.9","depth":1,"path":"chapters/10-cypress.md","ref":"chapters/10-cypress.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["mathjax"],"pluginsConfig":{"mathjax":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"preface.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}}},"file":{"path":"chapters/09-monitoring.md","mtime":"2021-03-10T03:55:43.063Z","type":"markdown"},"gitbook":{"version":"3.4.0","time":"2021-03-10T03:56:33.636Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-mathjax/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

